{"payload":{"meta":{"Graph":{"@Type":"81297157","@Value":{"Guid":"(Guid)0290faa1-7350-49ac-a13b-f3d8010db377","ParentGuid":"(Guid)fe54070b-3512-4a2f-b490-a57c15f4bfb5","Name":"(string)Status_Light","Properties":{"@Type":"2c41fa04:IDictionary","@Value":[{"@Key":"(Guid)829a18f2-c514-4f6e-9634-1df173429203","@Value":{"@Type":"829a18f2","@Value":{"ParentObjects":{"@Type":"fa2ee218:IDictionary","@Value":[{"@Key":"(Guid)d9b2b2cc-ea99-4c3b-aa42-1e5c49e65b84","@Value":"(Guid)1ec72487-961e-48d9-9aaf-0c51886640cf"}]}}}}]},"TypeGuid":"(Guid)6f9dac99-8de1-4efc-8465-68ac443b7d08","EmbeddedTypeGuids":{"@Type":"[Guid]","@Value":["(Guid)a9ed5b7e-75c5-4651-af16-d2c27e98cb94","(Guid)3b83b776-fb25-43b8-99f2-3c507c9143fc"]}}},"TypeInfos":{"2c41fa04":"{2c41fa04-1834-41c1-816e-303c7aa2c05b}","81297157":"{81297157-7ec9-45ce-845e-84cab2b88ade}","829a18f2":"{829a18f2-c514-4f6e-9634-1df173429203}","fa2ee218":"{fa2ee218-a39b-4b6d-b249-49dbddbd168a}","Guid":"System.Guid","string":"System.String"}},"object":{"Graph":{"@Type":"6f9dac99","@Value":{"SpecialFunc":{"@Type":"0db3d7bb:Enum","@Value":"None"},"Implementation":{"@Type":"3b83b776","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)//  This is part of the Warnings system.    It's designed to support DV2130 ( https://www.ifm.com/us/en/product/DV2130 ) and DV2131  ( https://www.ifm.com/us/en/product/DV2131 )   Add more if desired.\n\n//  This warning generates a notice to the operator that power was lost and restored (with timestamps.)\n\nIF NOT startup_tasks_done THEN\n\tIF SystemTime.dtDateTime <> DT#1970-01-1-00:00:00 THEN\t\t\t//  We do this check because it takes a second for the clock to start working.  Without this, the timestamp will be zero (Jan 1st  1970)\n\t\tWarnings(system_rebooted_warning);\n\t\tpvars.power_lost := pvars.we_had_power_now;\n\t\tpvars.power_restored_time := SystemTime.dtDateTime;\n\t\tstartup_tasks_done := TRUE;\n\tEND_IF\nEND_IF\n\nIF startup_tasks_done THEN\n\tpvars.we_had_power_now := SystemTime.dtDateTime;\t\t//  Resume updating our 'last successfull cycle' time record.\nEND_IF\n\n\n\n// Set status light color.   .0 bit = red   .1 bit = green   .2 is blue   .3 bit = yellow    .5 = fast flash.\n// Colors can be combined, ie. activating red, green and blue together gives an off-white.\n\n\nIF pVars.redWarningPresent THEN   \t\t\t//if there's an unfixed 'red' warning in the warning log\n\t\tstatusLight.0 := TRUE;\n\t\tstatusLight.1 := FALSE;\n\t\tstatusLight.2 := FALSE;\n\t\tstatusLight.3 := FALSE;\n\t\tstatusLight.5 := pVars.run;   \t\t\t\t\t\t\t\t\t\t// This is the 'flash' bit, so the warning light flashes red if the system is trying to run, but just steady red if stopped.\n\tELSIF pVars.yellowWarningPresent AND NOT pVars.redWarningPresent THEN  \t//if there's an unfixed 'yellow' but NOT 'red' warning in the warning log, turn light yellow\n\t\tstatusLight.0 := FALSE;\n\t\tstatusLight.1 := FALSE;\n\t\tstatusLight.2 := FALSE;\n\t\tstatusLight.3 := TRUE;\n\t\tstatusLight.5 := FALSE;\n\tELSIF pVars.run AND NOT pVars.yellowWarningPresent AND NOT pVars.redWarningPresent THEN  // If nothing's wrong and system is RUNNING turn the light green\n\t\tstatusLight.0 := FALSE;\n\t\tstatusLight.1 := TRUE;\n\t\tstatusLight.2 := FALSE;\n\t\tstatusLight.3 := FALSE;\n\t\tstatusLight.5 := FALSE;\n\tELSIF NOT pVars.run AND NOT pVars.yellowWarningPresent AND NOT pVars.redWarningPresent THEN  // If nothing's wrong and the system is STOPPED turn the light blue\n\t\tstatusLight.0 := FALSE;\n\t\tstatusLight.1 := FALSE;\n\t\tstatusLight.2 := TRUE;\n\t\tstatusLight.3 := FALSE;\n\t\tstatusLight.5 := FALSE;\nEND_IF\n\nstatuslight.8 := warnings_globals.siren; statuslight.12 := warnings_globals.siren;   //  Bit 8 and 12 will (if both true) turn on the light's audible alarm with a fast frequency.   Bit 8 enables, bit 12 selects fast alarm.\n\nIO_link_port.write_word_0 := statusLight;  // Write our constructed word to Port 4 (assuming a stack light is connected to port 4.)\n\n\n// Erase the Warnings log array if the reset button has been pressed on the Warning_log screen.\n// This lives here because the main Warnings POU is a function and won't react to the reset variable being triggered.\n\nsubcounter :=1; \t\t\t\t\t\t\t\t\t\t\t// Just a counter for our WHILE loop\nIF warnings_globals.WarningGlobalReset THEN\t\t\t\t\t// Somebody has pushed the RESET button on the Warning screen.\n\tpVars.yellowWarningPresent := FALSE;\t\t\t\t\t// Reset our status light color flags\n\tpVars.redWarningPresent := FALSE;\n\tpvars.blueWarningPresent := FALSE;\n\tWHILE subcounter <17 DO\t\t\t\t\t\t\t\t\t\t\t// Erase all elements of the Warnings array.\n\t\t\t\tpVars.myWarnings[subCounter] := blank_warning;\n\t\tsubcounter := subcounter + 1;\n\tEND_WHILE\n\twarnings_globals.warningSecondaryReset := TRUE;\n\twarnings_globals.WarningGlobalReset := FALSE;\nEND_IF\n\nIF warnings_globals.warningSecondaryReset AND TIME() - warnings_globals.resetTime > T#1S THEN\n\tpVars.redWarningPresent := FALSE;\n\tpVars.yellowWarningPresent := FALSE;\n\twarnings_globals.warningSecondaryReset := FALSE;\n\te_stop_warning_sent := FALSE;\nEND_IF\n\n//  Respond to the pressing of a Warning detail button in the Warning Log visu:\n\nIF warnings_globals.WarningButtonPressed <> 0 THEN\n\tVisuElems.CurrentVisu := pVars.myWarnings[warnings_globals.WarningButtonPressed].detail_warning_visu;\n\twarnings_globals.WarningButtonPressed := 0;\nEND_IF\n\n//  Generate an 'emergency stop pushed' warning.\n\nIF NOT e_stop_power_available AND NOT e_stop_warning_sent THEN\n\twarnings(e_stop_tripped_warning);\n\te_stop_warning_sent := TRUE;\nEND_IF\n\nIF (e_stop_warning_sent OR NOT e_stop_fix_sent) AND e_stop_power_available THEN\n\tWarnings(fix_e_stop_tripped_warning);\n\te_stop_warning_sent := FALSE;\n\te_stop_fix_sent := TRUE;\nEND_IF\n\n\n\n//    WARNINGS       WARNINGS     WARNINGS\n\nIF warnings_globals.warningSecondaryReset THEN    \t// This resets all of the 'warning sent' flags and other interface changes.\n\tstatus_light_unknown_sensor_sent:= FALSE;      \t// Reset our 'warning message sent' flag\n\n\tstatus_light_disconnected_sent := FALSE;\n\tConnection_lost_detected := FALSE;\n\tstatus_light_shorted_sent := FALSE;\n\t\nEND_IF\n(* UNKNOWN SENSOR WARNING!!      This warning checks if the device ID is an unfamiliar one OR if the vendor ID is not IFM's (310).\n\nTo avoid alarming on brief interruptions or during startup, there's a timer mechanism.   When an 'unknown device situation first occurs, a flag is set (Unknown_device_detected) and the event\nis timestamped (Unknown_device_time).\n*)\n\nIF NOT IO_link_port.not_connected   \t\t\t\t\t\t\t\t\t\t\t// This prevents it from generating a 'device unknown' when there's nothing at all connected.\n\tAND NOT Unknown_device_detected\t\t\t\t\t\t\t\t\t\t\t\t\t// Checks if we've already set our countdown flag\n\tAND NOT status_light_unknown_sensor_sent\t\t\t\t\t\t\t\t\t\t\t// Checks if we've already sent a Warning for this\n\tAND (IO_link_port.device_ID <> 1085\n\tAND IO_link_port.device_ID <> 1176\n\tOR IO_link_port.vendor_ID <> 310) \t\t \t// Checks if the vendor IDs and device IDs don't match known models.\n\tOR IO_link_port.vendor_ID = 0 THEN\t\t\t// If the device ID is zero, that indicates that the master block may be disconnected, not just the individual device.\n\t\tUnknown_device_time := TIME();\n\t\tUnknown_device_detected := TRUE;\nEND_IF\n\nIF IO_link_port.vendor_ID = 310 AND (IO_link_port.device_ID = 1085 OR IO_link_port.device_ID = 1176) THEN  // This resets our flag if we ARE seeing the correct sensor.\n\tUnknown_device_detected := FALSE;\nEND_IF\n\nIF Unknown_device_time + T#30S < TIME()\n\tAND Unknown_device_detected\n\tAND NOT status_light_unknown_sensor_sent THEN   // Check if the 'unknown device' error has persisted for at least 30 seconds.  If so, send Warning.\n\t\tstatus_light_unknown_sensor_sent := TRUE;\n\t\tWarnings (unknown_device_warning);\nEND_IF\n\n//  And this statement triggers if there was previously an 'unknown device' warning but now a known light is connected:\n\nIF status_light_unknown_sensor_sent AND IO_link_port.vendor_ID = 310 AND (IO_link_port.device_ID = 1085 OR IO_link_port.device_ID = 1176) THEN\n\tstatus_light_unknown_sensor_sent := FALSE;       \t\t//  Reset our 'warning sent' flag.\n\tWarnings (fix_unknown_device_warning);  \t\t\t\t//  Send the 'fixed' message\nEND_IF\n\n\n(*  DEVICE DISCONNECTED WARNING!!\n    This section checks if a sensor or device is connected.\n*)\n\nIF NOT Connection_lost_detected AND NOT status_light_disconnected_sent AND (IO_link_port.not_connected OR IO_link_port.data_invalid) THEN\n\tConnection_lost_time := TIME();\n\tConnection_lost_detected := TRUE;\nEND_IF\n\nIF NOT IO_link_port.not_connected AND NOT IO_link_port.data_invalid THEN  // This resets our flag if we ARE seeing a connected sensor.\n\tConnection_lost_detected := FALSE;\nEND_IF\n\nIF Connection_lost_time + T#30S < TIME() AND Connection_lost_detected AND NOT status_light_disconnected_sent THEN   // Check if the 'disconnected' error has persisted for at least 30 seconds.  If so, send Warning.\n\tstatus_light_disconnected_sent := TRUE;\n\tWarnings (disconnected_status_light_warning);\nEND_IF\n\n//  And this statement triggers if there was previously a 'disconnected' warning but now a device is connected:\n\nIF (status_light_disconnected_sent OR NOT fix_light_disconnected_sent) AND NOT IO_link_port.not_connected AND NOT IO_link_port.data_invalid THEN\n\tstatus_light_disconnected_sent := FALSE;       //  Reset our 'warning sent' flag.\n\tWarnings (fix_disconnected_status_light_warning);  //  Send the 'fixed' message\n\tfix_light_disconnected_sent := TRUE;\nEND_IF\n\n(*  DEVICE SHORT CIRCUIT WARNING!!\n    This section checks if a sensor or device is shorted (drawing too much power).\n*)\n\nIF NOT Short_detected AND NOT status_light_shorted_sent AND IO_link_port.short_circuit THEN\n\tShort_detected_time := TIME();\n\tShort_detected := TRUE;\nEND_IF\n\nIF NOT IO_link_port.short_circuit THEN  // This resets our flag if we no longer see a short.\n\tShort_detected := FALSE;\nEND_IF\n\nIF Short_detected_time + T#30S < TIME() AND Short_detected AND NOT status_light_shorted_sent THEN   // Check if the 'shorted' error has persisted for at least 30 seconds.  If so, send Warning.\n\tstatus_light_shorted_sent := TRUE;\n\tWarnings (shorted_light_warning);\nEND_IF\n\n//   this statement triggers if there was previously a 'shorted' warning but not anymore:\n\nIF status_light_shorted_sent AND NOT IO_link_port.not_connected AND NOT IO_link_port.data_invalid THEN\n\tstatus_light_shorted_sent := FALSE;       //  Reset our 'warning sent' flag.\n\tWarnings (fix_shorted_light_warning);  //  Send the 'fixed' message\nEND_IF\n","LineInfoPersistence":"(string)0290faa1-7350-49ac-a13b-f3d8010db377_Impl_LineIds"}}}},"Interface":{"@Type":"a9ed5b7e","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)PROGRAM Status_Light\nVAR;\n\tsubcounter: INT;\n\tstatusLight: WORD;\n\tblank_warning: warning_message;\n\tstartup_tasks_done: BOOL;\t\t//  Set to TRUE when we are done with some startup operations.\n\t\n\tsystem_rebooted_warning: warning_message :=  //  You need to populate a Warning struct to give the warning's details/config.\n\t\t(informational := TRUE,\n\t\tpop_up_everywhere := TRUE,\n\t\tdetail_warning_visu := 'W174',   //  This is the name of the visualization screen that describes this problem.   It MUST be accurate.\n\t\tshort_Description := 'System rebooted');  // A bit of text used on the short list of Warnings on the warnings_log screen.\n\n\te_stop_fix_sent: BOOL;\t\t\t//  This gets set to TRUE if we've sent the 'fixed' message at least once since the last reboot.   This allows the system to clear Warnings sent before the reboot.\n\t\n\te_stop_tripped_warning: warning_message := (red := TRUE, detail_warning_visu := 'W97', short_Description := 'Emergency Stop triggered');\n\t\n\tfix_e_stop_tripped_warning: warning_message := (fixed := TRUE, detail_warning_visu := 'W97');\n\n\n\tUnknown_device_detected: BOOL;\t\t\t\t\t\t//  Are we watching an unknown device condition?\n\tstatus_light_unknown_sensor_sent: BOOL;\t\t\t\t//  Have we sent an unknown device warning?\n\tUnknown_device_time: TIME;\t\t\t\t\t\t\t//  When did we first detect the problem?  Used to create a timer so we don't generate Warnings on a transient issue.\n\t\n\tunknown_device_warning: warning_message :=  \t\t\t\t\t\t//  You need to populate a Warning struct to give the warning's details/config.\n\t\t(yellow := TRUE,   \t\t\t\t\t\t\t\t\t\t// It's a yellow (non-fatal) warning\n\t\tpop_up_everywhere := FALSE,   \t\t\t\t\t\t\t//  Immediately switch the HMI to the detailed Warning notification.\n\t\tdetail_warning_visu := 'W172',   \t\t\t\t\t\t//  This is the name of the visualization screen that describes this problem.   It MUST be accurate.\n\t\tshort_Description := 'Unknown device (status light)');  \t// A bit of text used on the short list of Warnings on the warnings_log screen.\n\n\tfix_unknown_device_warning: warning_message :=    \t\t\t\t\t//  Here we create our 'fixed' message telling the system to mark the problem off as fixed.\n\t\t(fixed := TRUE,      \t  \t\t\t\t\t\t\t\t//  This flag literally defines it as a 'fixed' message  :-)\n\t\tdetail_warning_visu := 'W172');\t\t\t\t\t\t\t//  This allows the system to match this message with the previous warning in its list of Warnings.\n\t\n\t\t\n\tConnection_lost_detected: BOOL;\n\tstatus_light_disconnected_sent: BOOL;\n\tConnection_lost_time: TIME;\n\tfix_light_disconnected_sent: BOOL;\n\t\n\tdisconnected_status_light_warning: warning_message :=  \t\t\t\t\t\t//  You need to populate a Warning struct to give the warning's details/config.\n\t\t(yellow := TRUE,   \t\t\t\t\t\t\t\t\t\t// It's a yellow (non-fatal) warning\n\t\tpop_up_everywhere := FALSE,   \t\t\t\t\t\t\t//  Immediately switch the HMI to the detailed Warning notification.\n\t\tdetail_warning_visu := 'W25',   \t\t\t\t\t\t//  This is the name of the visualization screen that describes this problem.   It MUST be accurate.\n\t\tshort_Description := 'Status light disconnected');  \t\t// A bit of text used on the short list of Warnings on the warnings_log screen.\n\n\tfix_disconnected_status_light_warning: warning_message :=    \t\t\t\t\t//  Here we create our 'fixed' message telling the system to mark the problem off as fixed.\n\t\t(fixed := TRUE,      \t  \t\t\t\t\t\t\t\t//  This flag literally defines it as a 'fixed' message  :-)\n\t\tdetail_warning_visu := 'W25');\t\t\t\t\t\t\t//  This allows the system to match this message with the previous warning in its list of Warnings.\n\n\n\tShort_detected: BOOL;\n\tstatus_light_shorted_sent: BOOL;\n\tShort_detected_time: TIME;\n\t\n\tshorted_light_warning: warning_message :=  \t\t\t\t\t\t\t//  You need to populate a Warning struct to give the warning's details/config.\n\t\t(yellow := TRUE,   \t\t\t\t\t\t\t\t\t\t// It's a yellow (non-fatal) warning\n\t\tpop_up_everywhere := FALSE,   \t\t\t\t\t\t\t//  Immediately switch the HMI to the detailed Warning notification.\n\t\tdetail_warning_visu := 'W171',   \t\t\t\t\t\t//  This is the name of the visualization screen that describes this problem.   It MUST be accurate.\n\t\tshort_Description := 'Status light shorted out');  \t\t// A bit of text used on the short list of Warnings on the warnings_log screen.\n\n\tfix_shorted_light_warning: warning_message :=    \t\t\t\t\t//  Here we create our 'fixed' message telling the system to mark the problem off as fixed.\n\t\t(fixed := TRUE,      \t  \t\t\t\t\t\t\t\t//  This flag literally defines it as a 'fixed' message  :-)\n\t\tdetail_warning_visu := 'W171');\t\t\t\t\t\t\t//  This allows the system to match this message with the previous warning in its list of Warnings.\n\n\nEND_VAR\n\nVAR_OUTPUT\n\te_stop_warning_sent: BOOL;\t\t\t//  TRUE if we have already sent a warning that the system's e-stop has been pushed/tripped.\nEND_VAR\nVAR_INPUT\n\te_stop_power_available: BOOL;\t\t//  TRUE if the system is powered up, FALSE if the e-stop is tripped.\nEND_VAR\nvar_in_out\n\tIO_link_port: IO_link_port;\nEND_VAR","LineInfoPersistence":"(string)0290faa1-7350-49ac-a13b-f3d8010db377_Decl_LineIds"}}}},"UniqueIdGenerator":"(string)389","POULevel":{"@Type":"8e575c5b:Enum","@Value":"Standard"},"ChildObjectGuids":{"@Type":"ArrayList:IList","@Value":[]},"AddAttributeSubsequent":"(bool)False"}},"TypeInfos":{"0db3d7bb":"{0db3d7bb-cde0-4416-9a7b-ce49a0124323}","3b83b776":"{3b83b776-fb25-43b8-99f2-3c507c9143fc}","6f9dac99":"{6f9dac99-8de1-4efc-8465-68ac443b7d08}","8e575c5b":"{8e575c5b-1d37-49c6-941b-5c0ec7874787}","a9ed5b7e":"{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}","ArrayList":"System.Collections.ArrayList","bool":"System.Boolean","f3878285":"{f3878285-8e4f-490b-bb1b-9acbb7eb04db}","string":"System.String"}}},"FormatVersion":"1.0"}